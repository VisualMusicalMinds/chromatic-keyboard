<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Chromatic Piano (C3â€“F4)</title>
<style>
  :root {
    --white-w: 60px;
    --white-h: 240px;
    --black-w: 38px;
    --black-h: 150px;
  }
  body {
    margin: 0;
    font-family: system-ui, Arial, sans-serif;
    background: linear-gradient(#222, #444);
    color: #fff;
    display: grid;
    place-items: center;
    min-height: 100vh;
  }
  h1 { font-weight: 600; margin: 12px 0 6px; }
  .hint { opacity: 0.7; margin-bottom: 16px; font-size: 14px; min-height: 1.2em; }
  .controls { margin-bottom: 12px; font-size: 15px; }
  .controls select { font-size: 15px; }

  .keyboard {
    position: relative;
    display: block;
    width: calc(var(--white-w) * 11); /* 11 white keys C3..F4 */
    height: var(--white-h);
    box-shadow: 0 10px 30px rgba(0,0,0,.4);
    background: #111;
    border-radius: 8px;
    padding: 8px;
  }

  .whites, .blacks { position: absolute; inset: 8px; }

  .white-key {
    position: absolute;
    width: var(--white-w);
    height: var(--white-h);
    left: 0; top: 0;
    background: linear-gradient(#fff, #ddd);
    border: 1px solid #999;
    border-bottom: 3px solid #bbb;
    border-radius: 6px 6px 10px 10px;
    box-shadow: inset 0 -2px 0 #ccc;
    display: grid;
    place-items: end center;
    padding-bottom: 10px;
    color: #333;
    user-select: none;
    cursor: pointer;
    z-index: 1;
  }
  .white-key.pressed { background: linear-gradient(#f2f2f2, #cfcfcf); }

  .black-key {
    position: absolute;
    width: var(--black-w);
    height: var(--black-h);
    left: 0; top: 0;
    background: linear-gradient(#111, #333);
    border: 1px solid #000;
    border-radius: 6px 6px 8px 8px;
    box-shadow: 0 3px 6px rgba(0,0,0,.6), inset 0 -2px 0 rgba(255,255,255,.05);
    display: grid;
    place-items: end center;
    padding-bottom: 6px;
    color: #eee;
    user-select: none;
    cursor: pointer;
    z-index: 3; /* above whites */
  }
  .black-key.pressed { background: linear-gradient(#202020, #444); }

  .label {
    font-size: 12px;
    opacity: .8;
    pointer-events: none;
  }
</style>
</head>
<body>

<h1>Chromatic Piano</h1>
<div class="controls">
  <label for="octave-select">Octaves:</label>
  <select id="octave-select">
    <option value="1">1</option>
    <option value="2" selected>2</option>
    <option value="3">3</option>
    <option value="4">4</option>
  </select>
</div>
<div class="hint"></div>

<div class="keyboard" id="kb">
  <div class="whites" id="whites"></div>
  <div class="blacks" id="blacks"></div>
</div>

<script>
  // -------- AUDIO (pleasant tone, click-free) --------
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const ctx = new AudioCtx();

  // Single shared compressor (prevents pops, evens levels)
  const compressor = ctx.createDynamicsCompressor();
  compressor.threshold.value = -24;
  compressor.knee.value = 30;
  compressor.ratio.value = 12;
  compressor.attack.value = 0.003;
  compressor.release.value = 0.25;
  compressor.connect(ctx.destination);

  const active = new Map(); // note -> {osc, gain, filter}

  const pitchIndex = {
    'C':0, 'C#':1, 'Db':1,
    'D':2, 'D#':3, 'Eb':3,
    'E':4,
    'F':5, 'F#':6, 'Gb':6,
    'G':7, 'G#':8, 'Ab':8,
    'A':9, 'A#':10, 'Bb':10,
    'B':11
  };

  function freqOf(note, octaveOffset = 0) {
    // note like 'Db3', 'F4'
    const octave = parseInt(note.at(-1), 10) + octaveOffset;
    const pc = note.slice(0, -1); // e.g., 'Db'
    const idx = pitchIndex[pc];
    const noteNum = octave * 12 + idx;        // C0 = 0
    const A4num = 4 * 12 + 9;                 // A4
    return 440 * Math.pow(2, (noteNum - A4num) / 12);
  }

  function startNote(note, velocity = 0.35, octaveOffset = 0) {
    const finalNote = note.slice(0,-1) + (parseInt(note.at(-1), 10) + octaveOffset);
    if (active.has(finalNote)) return; // avoid retrigger while held
    
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const filter = ctx.createBiquadFilter();

    osc.type = 'triangle';
    osc.frequency.value = freqOf(note, octaveOffset);

    filter.type = 'lowpass';
    filter.frequency.value = 5200; // soften the top end a bit
    filter.Q.value = 0.8;

    // ADSR
    const now = ctx.currentTime;
    const A = 0.012, D = 0.06, S = 0.26; // sustain level
    gain.gain.cancelScheduledValues(now);
    gain.gain.setValueAtTime(0.0, now);
    gain.gain.linearRampToValueAtTime(velocity, now + A);
    gain.gain.linearRampToValueAtTime(S * velocity, now + A + D);

    osc.connect(filter).connect(gain).connect(compressor);
    osc.start(now);

    active.set(finalNote, { osc, gain });
  }

  function stopNote(note, octaveOffset = 0) {
    const finalNote = note.slice(0,-1) + (parseInt(note.at(-1), 10) + octaveOffset);
    const node = active.get(finalNote);
    if (!node) return;
    const { osc, gain } = node;
    const now = ctx.currentTime;
    const R = 0.18;
    gain.gain.cancelScheduledValues(now);
    gain.gain.setTargetAtTime(0.0001, now, R / 3); // smooth release
    osc.stop(now + R + 0.02);
    active.delete(finalNote);
  }

  // -------- LAYOUT --------
  const whitesEl = document.getElementById('whites');
  const blacksEl = document.getElementById('blacks');
  const hintEl = document.querySelector('.hint');

  // Will be dynamically populated
  let whiteKeysPhysical = [];
  let blackKeysPhysical = [];
  
  const keyNoteMap = {
    // White keys
    'z':'C3', 'x':'D3', 'c':'E3', 'v':'F3', 'b':'G3', 'n':'A3', 'm':'B3',
    ',':'C4', '.':'D4', '/':'E4',
    'q':'C4', 'w':'D4', 'e':'E4', 'r':'F4', 't':'G4', 'y':'A4', 'u':'B4',
    'i':'C5', 'o':'D5', 'p':'E5',
    // Black keys
    's':'Db3', 'd':'Eb3', 'g':'Gb3', 'h':'Ab3', 'j':'Bb3',
    'l':'Db4', ';':'Eb4',
    '2':'Db4', '3':'Eb4', '5':'Gb4', '6':'Ab4', '7':'Bb4',
    '9':'Db5', '0':'Eb5',
  };

  function drawKeyboard(numOctaves = 2) {
    // Clear previous keys
    whitesEl.innerHTML = '';
    blacksEl.innerHTML = '';

    // Create a reverse map from note to key(s) for labels
    const noteKeyMap = {};
    for (const key in keyNoteMap) {
      const note = keyNoteMap[key];
      if (!noteKeyMap[note]) {
        noteKeyMap[note] = [];
      }
      noteKeyMap[note].push(key);
    }

    // Generate the notes for the selected number of octaves
    whiteKeysPhysical = [];
    blackKeysPhysical = [];

    const startOctave = 3;
    const noteOrder = ['C','Db','D','Eb','E','F','Gb','G','Ab','A','Bb','B'];
    const fullKeyboard = [];

    for (let o = 0; o < numOctaves + 1; o++) { // Generate a bit more to ensure we can get to E
        for(const noteName of noteOrder) {
            fullKeyboard.push(noteName + (startOctave + o));
        }
    }

    const endNote = 'E' + (startOctave + numOctaves -1 + 1);
    const endIndex = fullKeyboard.indexOf(endNote);
    const finalKeyboard = fullKeyboard.slice(0, endIndex + 1);
    
    finalKeyboard.forEach(note => {
        if (note.includes('#') || note.includes('b')) {
            blackKeysPhysical.push(note);
        } else {
            whiteKeysPhysical.push(note);
        }
    });
    
    // Black key placement logic
    const blackBetweenIndex = {};
    blackKeysPhysical.forEach(note => {
        const octave = parseInt(note.at(-1), 10);
        const pc = note.slice(0, -1); // e.g., 'Db'
        let referenceNote;
        switch(pc) {
            case 'Db': referenceNote = 'C' + octave; break;
            case 'Eb': referenceNote = 'D' + octave; break;
            case 'Gb': referenceNote = 'F' + octave; break;
            case 'Ab': referenceNote = 'G' + octave; break;
            case 'Bb': referenceNote = 'A' + octave; break;
        }
        const idx = whiteKeysPhysical.indexOf(referenceNote);
        if (idx !== -1) {
            blackBetweenIndex[note] = idx;
        }
    });


    // Sizing
    const totalWhiteKeys = whiteKeysPhysical.length;
    const maxKeyboardWidth = window.innerWidth * 0.9;
    let whiteKeyWidth = Math.min(60, maxKeyboardWidth / totalWhiteKeys);
    let blackKeyWidth = whiteKeyWidth * 0.6;

    document.documentElement.style.setProperty('--white-w', `${whiteKeyWidth}px`);
    document.documentElement.style.setProperty('--black-w', `${blackKeyWidth}px`);
    const keyboardWidth = totalWhiteKeys * whiteKeyWidth;
    document.getElementById('kb').style.width = `${keyboardWidth}px`;


    // Create white key elements
    whiteKeysPhysical.forEach((note, i) => {
        const div = document.createElement('div');
        div.className = 'white-key';
        div.style.left = `${i * whiteKeyWidth}px`;
        div.dataset.note = note;
        const keyLabel = noteKeyMap[note] ? `<div class="label">${noteKeyMap[note].join('/')}</div>` : '';
        div.innerHTML = keyLabel;
        whitesEl.appendChild(div);
        
        div.addEventListener('mousedown', () => onPointerDown(note));
        div.addEventListener('mouseup',   () => onPointerUp(note));
        div.addEventListener('mouseleave',() => onPointerUp(note));
        div.addEventListener('touchstart',(ev) => { ev.preventDefault(); onPointerDown(note); }, {passive:false});
        div.addEventListener('touchend',  () => onPointerUp(note));
    });

    // Create black key elements
    blackKeysPhysical.forEach((note, i) => {
        const div = document.createElement('div');
        div.className = 'black-key';
        const leftIndex = blackBetweenIndex[note];
        if (leftIndex === undefined) return;
        const x = (leftIndex + 1) * whiteKeyWidth - (blackKeyWidth / 2);
        div.style.left = `${x}px`;
        div.dataset.note = note;
        const keyLabel = noteKeyMap[note] ? `<div class="label">${noteKeyMap[note].join('/')}</div>` : '';
        div.innerHTML = keyLabel;
        blacksEl.appendChild(div);

        div.addEventListener('mousedown', () => onPointerDown(note));
        div.addEventListener('mouseup',   () => onPointerUp(note));
        div.addEventListener('mouseleave',() => onPointerUp(note));
        div.addEventListener('touchstart',(ev) => { ev.preventDefault(); onPointerDown(note); }, {passive:false});
        div.addEventListener('touchend',  () => onPointerUp(note));
    });
    
    // Update hint
    let hintText = "Hint:<br>";
    const hints = [
        "Oct 1: zxcvbnm,./ (white) | sdghjl; (black)",
        "Oct 2: qwertyuiop (white) | 2356790 (black)",
    ];
    
    if (numOctaves >= 1) {
        hintText += hints[0];
    }
    if (numOctaves >= 2) {
        hintText += "<br>" + hints[1];
    }
    hintText += "<br>Shift or CapsLock for +2 octaves";
    hintEl.innerHTML = hintText;
  }

  // -------- INTERACTION --------
  function pressVisual(note, pressed) {
    const el = document.querySelector(`[data-note="${note}"]`);
    if (!el) return;
    el.classList.toggle('pressed', pressed);
  }

  const downKeys = new Set(); // prevent auto-repeat stacking

  function keyToNote(key) {
    return keyNoteMap[key] || null;
  }

  document.addEventListener('keydown', (e) => {
    if (e.repeat) return;
    const isShifted = e.shiftKey || e.getModifierState("CapsLock");
    let key = e.key;

    // Handle special keys for shifted black notes
    if (isShifted) {
        const shiftedBlackMap = {'@':'2', '#':'3', '%':'5', '^':'6', '&':'7', '(':'9', ')':'0'};
        if (shiftedBlackMap[key]) {
            key = shiftedBlackMap[key];
        }
    }

    const note = keyToNote(key);
    if (!note) return;

    if (ctx.state !== 'running') ctx.resume();
    downKeys.add(e.key);
    pressVisual(note, true);

    const octaveOffset = (isShifted) ? 2 : 0;
    startNote(note, 0.35, octaveOffset);
  });

  document.addEventListener('keyup', (e) => {
    if (!downKeys.has(e.key)) return;
    downKeys.delete(e.key);

    const isShifted = e.shiftKey || e.getModifierState("CapsLock");
    let key = e.key;
    if (isShifted) {
        const shiftedBlackMap = {'@':'2', '#':'3', '%':'5', '^':'6', '&':'7', '(':'9', ')':'0'};
        if (shiftedBlackMap[key]) {
            key = shiftedBlackMap[key];
        }
    }
    const note = keyToNote(key);
    if (!note) return;

    pressVisual(note, false);
    const octaveOffset = (isShifted) ? 2 : 0;
    stopNote(note, octaveOffset);
  });

  // Mouse / touch
  let capsLock = false;
  window.addEventListener('keydown', e => {
      if (e.key === 'CapsLock') capsLock = !capsLock;
  });

  function onPointerDown(note) {
    if (ctx.state !== 'running') ctx.resume();
    pressVisual(note, true);
    const octaveOffset = capsLock ? 2 : 0;
    startNote(note, 0.35, octaveOffset);
  }
  function onPointerUp(note) {
    pressVisual(note, false);
    const octaveOffset = capsLock ? 2 : 0;
    stopNote(note, octaveOffset);
  }

  // Initial draw
  const octaveSelect = document.getElementById('octave-select');
  octaveSelect.addEventListener('change', (e) => {
    drawKeyboard(parseInt(e.target.value, 10));
  });

  drawKeyboard(parseInt(octaveSelect.value, 10));
</script>
</body>
</html>
