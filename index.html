<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Chromatic Piano (C3â€“F4)</title>
<style>
  :root {
    --white-w: 60px;
    --white-h: 240px;
    --black-w: 38px;
    --black-h: 150px;
  }
  body {
    margin: 0;
    font-family: system-ui, Arial, sans-serif;
    background: linear-gradient(#222, #444);
    color: #fff;
    display: grid;
    place-items: center;
    min-height: 100vh;
  }
  h1 { font-weight: 600; margin: 12px 0 6px; }
  .hint { opacity: 0.7; margin-bottom: 16px; font-size: 14px; min-height: 1.2em; }
  .controls { margin-bottom: 12px; font-size: 15px; display: flex; align-items: center; gap: 20px; }
  .controls select { font-size: 15px; }

  .keyboard {
    position: relative;
    display: block;
    width: calc(var(--white-w) * 11); /* 11 white keys C3..F4 */
    height: var(--white-h);
    box-shadow: 0 10px 30px rgba(0,0,0,.4);
    background: #111;
    border-radius: 8px;
    padding: 8px;
  }

  .whites, .blacks { position: absolute; inset: 8px; }

  .white-key {
    position: absolute;
    width: var(--white-w);
    height: var(--white-h);
    left: 0; top: 0;
    background: linear-gradient(#fff, #ddd);
    border: 1px solid #999;
    border-bottom: 3px solid #bbb;
    border-radius: 6px 6px 10px 10px;
    box-shadow: inset 0 -2px 0 #ccc;
    display: grid;
    place-items: end center;
    padding-bottom: 10px;
    color: #333;
    user-select: none;
    cursor: pointer;
    z-index: 1;
  }
  .white-key.pressed { background: linear-gradient(#f2f2f2, #cfcfcf); }

  .black-key {
    position: absolute;
    width: var(--black-w);
    height: var(--black-h);
    left: 0; top: 0;
    background: linear-gradient(#111, #333);
    border: 1px solid #000;
    border-radius: 6px 6px 8px 8px;
    box-shadow: 0 3px 6px rgba(0,0,0,.6), inset 0 -2px 0 rgba(255,255,255,.05);
    display: grid;
    place-items: end center;
    padding-bottom: 6px;
    color: #eee;
    user-select: none;
    cursor: pointer;
    z-index: 3; /* above whites */
  }
  .black-key.pressed { background: linear-gradient(#202020, #444); }

  .label {
    font-size: 12px;
    opacity: .8;
    pointer-events: none;
  }
  
  /* Sound selector styles */
  .sound-selector {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 20px;
    gap: 8px;
  }
  
  .sound-dial {
    position: relative;
    width: 150px;
    height: 80px;
    background: #333;
    border-radius: 12px;
    padding: 15px 20px;
    box-shadow: 0 4px 8px rgba(0,0,0,.3), inset 0 1px 1px rgba(255,255,255,.1);
    user-select: none;
  }
  
  .dial-title {
    text-align: center;
    margin-bottom: 10px;
    font-size: 14px;
    font-weight: 600;
    color: #ddd;
  }
  
  .dial-options {
    display: flex;
    justify-content: space-between;
    position: relative;
    height: 40px;
  }
  
  .dial-option {
    position: relative;
    width: 25%;
    display: flex;
    flex-direction: column;
    align-items: center;
    cursor: pointer;
    opacity: 0.6;
    transition: opacity 0.2s;
  }
  
  .dial-option:hover {
    opacity: 0.8;
  }
  
  .dial-option.active {
    opacity: 1;
  }
  
  .dial-dot {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    margin-bottom: 6px;
    box-shadow: 0 1px 3px rgba(0,0,0,.4);
  }
  
  .dial-label {
    font-size: 11px;
    color: #ddd;
  }
  
  /* Color each sound type */
  .piano .dial-dot { background: #50c0e9; }
  .synth .dial-dot { background: #50e97b; }
  .organ .dial-dot { background: #e95050; }
  .cosmic .dial-dot { background: #bf50e9; }
  
  /* Dial indicator line */
  .dial-indicator {
    position: absolute;
    bottom: 28px;
    left: 18.75%;
    width: 12px;
    height: 12px;
    background: #fff;
    border-radius: 50%;
    transform: translateX(-50%);
    transition: left 0.3s ease;
    box-shadow: 0 0 8px rgba(255,255,255,.5);
    z-index: 2;
  }
  
  .dial-line {
    position: absolute;
    height: 2px;
    background: #666;
    bottom: 34px;
    left: 0;
    right: 0;
    z-index: 1;
  }
</style>
</head>
<body>

<h1>Chromatic Piano</h1>
<div class="controls">
  <label for="octave-select">Octaves:</label>
  <select id="octave-select">
    <option value="1">1</option>
    <option value="2" selected>2</option>
    <option value="3">3</option>
    <option value="4">4</option>
  </select>
</div>
<div class="hint"></div>

<div class="sound-selector">
  <div class="sound-dial">
    <div class="dial-title">Sound Type</div>
    <div class="dial-line"></div>
    <div class="dial-indicator"></div>
    <div class="dial-options">
      <div class="dial-option piano active" data-sound="piano">
        <div class="dial-dot"></div>
        <div class="dial-label">Piano</div>
      </div>
      <div class="dial-option synth" data-sound="synth">
        <div class="dial-dot"></div>
        <div class="dial-label">Synth</div>
      </div>
      <div class="dial-option organ" data-sound="organ">
        <div class="dial-dot"></div>
        <div class="dial-label">Organ</div>
      </div>
      <div class="dial-option cosmic" data-sound="cosmic">
        <div class="dial-dot"></div>
        <div class="dial-label">Cosmic</div>
      </div>
    </div>
  </div>
</div>

<div class="keyboard" id="kb">
  <div class="whites" id="whites"></div>
  <div class="blacks" id="blacks"></div>
</div>

<script>
  // -------- AUDIO (pleasant tone, click-free) --------
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const ctx = new AudioCtx();

  // Single shared compressor (prevents pops, evens levels)
  const compressor = ctx.createDynamicsCompressor();
  compressor.threshold.value = -24;
  compressor.knee.value = 30;
  compressor.ratio.value = 12;
  compressor.attack.value = 0.003;
  compressor.release.value = 0.25;
  compressor.connect(ctx.destination);

  const active = new Map(); // note -> {osc, gain, filter}
  let currentSound = "piano"; // Default sound

  // Sound profiles
  const soundProfiles = {
    piano: {
      oscillator: "triangle",
      attack: 0.012,
      decay: 0.06,
      sustain: 0.26,
      release: 0.18,
      filterType: "lowpass",
      filterFreq: 5200,
      filterQ: 0.8,
      setup: (osc, filter, gain, velocity) => {
        // Default piano sound
      }
    },
    synth: {
      oscillator: "sawtooth",
      attack: 0.03,
      decay: 0.1,
      sustain: 0.5,
      release: 0.4,
      filterType: "lowpass",
      filterFreq: 2500,
      filterQ: 5,
      setup: (osc, filter, gain, velocity) => {
        // Add detune for rich synth sound
        osc.detune.value = Math.random() * 10 - 5;
        
        // Create a second oscillator for richer sound
        const osc2 = ctx.createOscillator();
        osc2.type = "square";
        osc2.frequency.value = osc.frequency.value;
        osc2.detune.value = 7; // Slight detune for chorus effect
        
        // Gain for second oscillator
        const gain2 = ctx.createGain();
        gain2.gain.value = 0.15;
        
        osc2.connect(gain2).connect(filter);
        osc2.start();
        
        return { additionalOsc: osc2 };
      }
    },
    organ: {
      oscillator: "sine",
      attack: 0.005,
      decay: 0.01,
      sustain: 0.98,
      release: 0.08,
      filterType: "highpass",
      filterFreq: 100,
      filterQ: 0.1,
      setup: (osc, filter, gain, velocity) => {
        // Create multiple oscillators for organ-like harmonics
        const harmonics = [1, 2, 3, 4];
        const additionalOscs = [];
        
        for (let i = 1; i < harmonics.length; i++) {
          const harmOsc = ctx.createOscillator();
          harmOsc.type = "sine";
          harmOsc.frequency.value = osc.frequency.value * harmonics[i];
          
          const harmGain = ctx.createGain();
          harmGain.gain.value = velocity * (0.75 / (i+1)); // Decrease volume for higher harmonics
          
          harmOsc.connect(harmGain).connect(filter);
          harmOsc.start();
          additionalOscs.push(harmOsc);
        }
        
        // Override filter settings for organ
        filter.type = "lowpass";
        filter.frequency.value = 3000;
        
        return { additionalOscs };
      }
    },
    cosmic: {
      oscillator: "sine",
      attack: 0.1,
      decay: 0.4,
      sustain: 0.4,
      release: 2.0,
      filterType: "bandpass",
      filterFreq: 1000,
      filterQ: 4,
      setup: (osc, filter, gain, velocity) => {
        // Create modulation
        const lfo = ctx.createOscillator();
        const lfoGain = ctx.createGain();
        lfo.frequency.value = 5 + Math.random() * 3; // Random LFO rate
        lfoGain.gain.value = 100; // LFO depth
        
        // Connect LFO to filter frequency
        lfo.connect(lfoGain);
        lfoGain.connect(filter.frequency);
        lfo.start();
        
        // Add delay for spacey effect
        const delay = ctx.createDelay();
        const delayFeedback = ctx.createGain();
        delay.delayTime.value = 0.4;
        delayFeedback.gain.value = 0.3;
        
        gain.connect(delay);
        delay.connect(delayFeedback);
        delayFeedback.connect(delay);
        delay.connect(compressor);
        
        return { lfo, delay };
      }
    }
  };

  const pitchIndex = {
    'C':0, 'C#':1, 'Db':1,
    'D':2, 'D#':3, 'Eb':3,
    'E':4,
    'F':5, 'F#':6, 'Gb':6,
    'G':7, 'G#':8, 'Ab':8,
    'A':9, 'A#':10, 'Bb':10,
    'B':11
  };

  function freqOf(note, octaveOffset = 0) {
    // note like 'Db3', 'F4'
    const octave = parseInt(note.at(-1), 10) + octaveOffset;
    const pc = note.slice(0, -1); // e.g., 'Db'
    const idx = pitchIndex[pc];
    const noteNum = octave * 12 + idx;        // C0 = 0
    const A4num = 4 * 12 + 9;                 // A4
    return 440 * Math.pow(2, (noteNum - A4num) / 12);
  }

  function startNote(note, velocity = 0.35, octaveOffset = 0) {
    const finalNote = note.slice(0,-1) + (parseInt(note.at(-1), 10) + octaveOffset);
    if (active.has(finalNote)) return; // avoid retrigger while held
    
    const profile = soundProfiles[currentSound];
    
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const filter = ctx.createBiquadFilter();

    osc.type = profile.oscillator;
    osc.frequency.value = freqOf(note, octaveOffset);

    filter.type = profile.filterType;
    filter.frequency.value = profile.filterFreq;
    filter.Q.value = profile.filterQ;

    // ADSR
    const now = ctx.currentTime;
    const A = profile.attack, D = profile.decay, S = profile.sustain; // sustain level
    gain.gain.cancelScheduledValues(now);
    gain.gain.setValueAtTime(0.0, now);
    gain.gain.linearRampToValueAtTime(velocity, now + A);
    gain.gain.linearRampToValueAtTime(S * velocity, now + A + D);

    osc.connect(filter).connect(gain).connect(compressor);
    osc.start(now);
    
    // Apply sound-specific setups and collect any additional nodes
    const additionalNodes = profile.setup ? profile.setup(osc, filter, gain, velocity) : {};
    
    active.set(finalNote, { 
      osc, 
      gain, 
      filter,
      ...additionalNodes
    });
  }

  function stopNote(note, octaveOffset = 0) {
    const finalNote = note.slice(0,-1) + (parseInt(note.at(-1), 10) + octaveOffset);
    const node = active.get(finalNote);
    if (!node) return;
    
    const { osc, gain } = node;
    const profile = soundProfiles[currentSound];
    const now = ctx.currentTime;
    const R = profile.release;
    
    gain.gain.cancelScheduledValues(now);
    gain.gain.setTargetAtTime(0.0001, now, R / 3); // smooth release
    osc.stop(now + R + 0.02);
    
    // Clean up any additional oscillators
    if (node.additionalOsc) {
      node.additionalOsc.stop(now + R + 0.02);
    }
    
    if (node.additionalOscs) {
      node.additionalOscs.forEach(osc => {
        osc.stop(now + R + 0.02);
      });
    }
    
    if (node.lfo) {
      node.lfo.stop(now + R + 0.02);
    }
    
    active.delete(finalNote);
  }

  // -------- LAYOUT --------
  const whitesEl = document.getElementById('whites');
  const blacksEl = document.getElementById('blacks');
  const hintEl = document.querySelector('.hint');

  // Will be dynamically populated
  let whiteKeysPhysical = [];
  let blackKeysPhysical = [];
  
  const keyNoteMap = {
    // White keys
    'z':'C3', 'x':'D3', 'c':'E3', 'v':'F3', 'b':'G3', 'n':'A3', 'm':'B3',
    ',':'C4', '.':'D4', '/':'E4',
    'q':'C4', 'w':'D4', 'e':'E4', 'r':'F4', 't':'G4', 'y':'A4', 'u':'B4',
    'i':'C5', 'o':'D5', 'p':'E5',
    // Black keys
    's':'Db3', 'd':'Eb3', 'g':'Gb3', 'h':'Ab3', 'j':'Bb3',
    'l':'Db4', ';':'Eb4',
    '2':'Db4', '3':'Eb4', '5':'Gb4', '6':'Ab4', '7':'Bb4',
    '9':'Db5', '0':'Eb5',
  };

  function drawKeyboard(numOctaves = 2) {
    // Clear previous keys
    whitesEl.innerHTML = '';
    blacksEl.innerHTML = '';

    // Create a reverse map from note to key(s) for labels
    const noteKeyMap = {};
    for (const key in keyNoteMap) {
      const note = keyNoteMap[key];
      if (!noteKeyMap[note]) {
        noteKeyMap[note] = [];
      }
      noteKeyMap[note].push(key);
    }

    // Generate the notes for the selected number of octaves
    whiteKeysPhysical = [];
    blackKeysPhysical = [];

    const startOctave = 3;
    const noteOrder = ['C','Db','D','Eb','E','F','Gb','G','Ab','A','Bb','B'];
    const fullKeyboard = [];

    for (let o = 0; o < numOctaves + 1; o++) { // Generate a bit more to ensure we can get to E
        for(const noteName of noteOrder) {
            fullKeyboard.push(noteName + (startOctave + o));
        }
    }

    const endNote = 'E' + (startOctave + numOctaves -1 + 1);
    const endIndex = fullKeyboard.indexOf(endNote);
    const finalKeyboard = fullKeyboard.slice(0, endIndex + 1);
    
    finalKeyboard.forEach(note => {
        if (note.includes('#') || note.includes('b')) {
            blackKeysPhysical.push(note);
        } else {
            whiteKeysPhysical.push(note);
        }
    });
    
    // Black key placement logic
    const blackBetweenIndex = {};
    blackKeysPhysical.forEach(note => {
        const octave = parseInt(note.at(-1), 10);
        const pc = note.slice(0, -1); // e.g., 'Db'
        let referenceNote;
        switch(pc) {
            case 'Db': referenceNote = 'C' + octave; break;
            case 'Eb': referenceNote = 'D' + octave; break;
            case 'Gb': referenceNote = 'F' + octave; break;
            case 'Ab': referenceNote = 'G' + octave; break;
            case 'Bb': referenceNote = 'A' + octave; break;
        }
        const idx = whiteKeysPhysical.indexOf(referenceNote);
        if (idx !== -1) {
            blackBetweenIndex[note] = idx;
        }
    });


    // Sizing
    const totalWhiteKeys = whiteKeysPhysical.length;
    const maxKeyboardWidth = window.innerWidth * 0.9;
    let whiteKeyWidth = Math.min(60, maxKeyboardWidth / totalWhiteKeys);
    let blackKeyWidth = whiteKeyWidth * 0.6;

    document.documentElement.style.setProperty('--white-w', `${whiteKeyWidth}px`);
    document.documentElement.style.setProperty('--black-w', `${blackKeyWidth}px`);
    const keyboardWidth = totalWhiteKeys * whiteKeyWidth;
    document.getElementById('kb').style.width = `${keyboardWidth}px`;


    // Create white key elements
    whiteKeysPhysical.forEach((note, i) => {
        const div = document.createElement('div');
        div.className = 'white-key';
        div.style.left = `${i * whiteKeyWidth}px`;
        div.dataset.note = note;
        const keyLabel = noteKeyMap[note] ? `<div class="label">${noteKeyMap[note].join('/')}</div>` : '';
        div.innerHTML = keyLabel;
        whitesEl.appendChild(div);
        
        div.addEventListener('mousedown', () => onPointerDown(note));
        div.addEventListener('mouseup',   () => onPointerUp(note));
        div.addEventListener('mouseleave',() => onPointerUp(note));
        div.addEventListener('touchstart',(ev) => { ev.preventDefault(); onPointerDown(note); }, {passive:false});
        div.addEventListener('touchend',  () => onPointerUp(note));
    });

    // Create black key elements
    blackKeysPhysical.forEach((note, i) => {
        const div = document.createElement('div');
        div.className = 'black-key';
        const leftIndex = blackBetweenIndex[note];
        if (leftIndex === undefined) return;
        const x = (leftIndex + 1) * whiteKeyWidth - (blackKeyWidth / 2);
        div.style.left = `${x}px`;
        div.dataset.note = note;
        const keyLabel = noteKeyMap[note] ? `<div class="label">${noteKeyMap[note].join('/')}</div>` : '';
        div.innerHTML = keyLabel;
        blacksEl.appendChild(div);

        div.addEventListener('mousedown', () => onPointerDown(note));
        div.addEventListener('mouseup',   () => onPointerUp(note));
        div.addEventListener('mouseleave',() => onPointerUp(note));
        div.addEventListener('touchstart',(ev) => { ev.preventDefault(); onPointerDown(note); }, {passive:false});
        div.addEventListener('touchend',  () => onPointerUp(note));
    });
    
    // Update hint
    let hintText = "Hint:<br>";
    const hints = [
        "Oct 1: zxcvbnm,./ (white) | sdghjl; (black)",
        "Oct 2: qwertyuiop (white) | 2356790 (black)",
    ];
    
    if (numOctaves >= 1) {
        hintText += hints[0];
    }
    if (numOctaves >= 2) {
        hintText += "<br>" + hints[1];
    }
    hintText += "<br>Shift or CapsLock for +2 octaves";
    hintEl.innerHTML = hintText;
  }

  // -------- INTERACTION --------
  function pressVisual(note, pressed) {
    const el = document.querySelector(`[data-note="${note}"]`);
    if (!el) return;
    el.classList.toggle('pressed', pressed);
  }

  const downKeys = new Map(); // Use a map to store state for each key

  function keyToNote(key) {
    return keyNoteMap[key] || null;
  }

  document.addEventListener('keydown', (e) => {
    if (e.repeat || downKeys.has(e.code)) return;

    const isShifted = e.shiftKey || e.getModifierState("CapsLock");
    let key = e.key;

    if (isShifted) {
        const shiftedBlackMap = {'@':'2', '#':'3', '%':'5', '^':'6', '&':'7', '(':'9', ')':'0'};
        if (shiftedBlackMap[key]) {
            key = shiftedBlackMap[key];
        }
    }
    if (key.length === 1 && key.toLowerCase() !== key.toUpperCase()) {
        key = key.toLowerCase();
    }

    const note = keyToNote(key);
    if (!note) return;

    if (ctx.state !== 'running') ctx.resume();
    downKeys.set(e.code, { note: note, shifted: isShifted });
    pressVisual(note, true);

    const octaveOffset = (isShifted) ? 2 : 0;
    startNote(note, 0.35, octaveOffset);
  });

  document.addEventListener('keyup', (e) => {
    const downKeyInfo = downKeys.get(e.code);
    if (!downKeyInfo) return;
    downKeys.delete(e.code);

    const { note, shifted } = downKeyInfo;

    pressVisual(note, false);
    const octaveOffset = (shifted) ? 2 : 0;
    stopNote(note, octaveOffset);
  });

  // Mouse / touch
  let capsLock = false;
  window.addEventListener('keydown', e => {
      if (e.key === 'CapsLock') capsLock = !capsLock;
  });

  function onPointerDown(note) {
    if (ctx.state !== 'running') ctx.resume();
    pressVisual(note, true);
    const octaveOffset = capsLock ? 2 : 0;
    startNote(note, 0.35, octaveOffset);
  }
  function onPointerUp(note) {
    pressVisual(note, false);
    const octaveOffset = capsLock ? 2 : 0;
    stopNote(note, octaveOffset);
  }

  // Initial draw
  const octaveSelect = document.getElementById('octave-select');
  octaveSelect.addEventListener('change', (e) => {
    drawKeyboard(parseInt(e.target.value, 10));
  });

  // Sound selector functionality
  const dialOptions = document.querySelectorAll('.dial-option');
  const dialIndicator = document.querySelector('.dial-indicator');
  
  dialOptions.forEach((option, index) => {
    option.addEventListener('click', () => {
      // Update active option
      dialOptions.forEach(opt => opt.classList.remove('active'));
      option.classList.add('active');
      
      // Move the indicator
      const positions = [18.75, 43.75, 68.75, 93.75]; // Position percentages for 4 options
      dialIndicator.style.left = positions[index] + '%';
      
      // Update sound type
      currentSound = option.dataset.sound;
      
      // Stop any currently playing notes to prevent inconsistent sound state
      for (const [note, nodeInfo] of active.entries()) {
        stopNote(note, 0);
      }
    });
  });

  drawKeyboard(parseInt(octaveSelect.value, 10));
</script>
</body>
</html>
